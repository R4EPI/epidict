#' @noRd
#'
#' @param dictionary Specify which dictionary you would like to use.
#'   Currently supports "Cholera", "Measles", "Meningitis", "AJS",
#'    "Mortality" and "Vaccination" ("Nutrition" to be added)
#'
#' @param varnames Specify name of column that contains varnames. Currently
#'   default set to "Item".  (this can probably be deleted once dictionaries
#'   standardise) If `dictionary` is a survey, `varnames` needs to be "name".
#'
#' @param numcases For fake data, specify the number of cases you want (default is 300)
#'
#' @keywords internal
gen_msf_data <- function(dictionary, dat_dict, is_survey, varnames = "data_element_shortname", numcases = 300) {

  # Three datasets:
  # 1) dat_dict = msf data dictionary generated by (msf_dict)
  # 2) dat_output = formatting of data dictionary to make use for sampling
  # 3) dis_output = dictionary dataset generated from sampling (exported)

  # # drop extra columns (keep varnames and code options)
  dis_output <- template_data_frame_categories(dat_dict, numcases, varnames, survey = is_survey)

  # Use data dictionary to define which vars are dates
  if(is_survey) {
    datevars <- dat_dict[[varnames]][dat_dict$type == "date"]
  } else {
    datevars <- dat_dict[[varnames]][dat_dict$data_element_valuetype == "DATE"]
  }


  # sample between two dates
  posidates <- seq(as.Date("2018-01-01"), as.Date("2018-04-30"), by = "day")

  # fill the date columns with dates
  for (i in datevars) {
    dis_output[[i]] <- sample(posidates, numcases, replace = TRUE)
  }

  if (!is_survey) {

    # Make sure exit dates don't come before entrance dates
    dis_output <- fix_dates(dis_output)

    # Patient identifiers
    dis_output$case_number <- sprintf("A%d", seq(numcases))

    # treatment site facility
    dis_output$treatment_facility_site <- sample(1:50, numcases, replace = TRUE)

    # patient origin (categorical from a dropdown)
    dis_output$patient_origin <- gen_village(numcases)

    # treatment location (categorical from a dropdown)
    dis_output$treatment_location <- gen_ward(numcases)

    # patient origin free text
    dis_output$patient_origin_free_text <- gen_freetext(numcases)
  }

  # GENERATE AGES --------------------------------------------------------------

  # think this is only relevant for outbreaks!
  dis_output <- gen_ages(
    dis_output, 
    numcases,
    set_age_na = !is_survey,
    year_cutoff = if (is_survey) 0 else 2
  )


  # DISEASE-SPECIFIC GENERATORS ------------------------------------------------
  if (dictionary == "Cholera" | dictionary == "Measles" | dictionary == "AJS") {
    # In this case, not female == not applicable
    dis_output$pregnant[dis_output$sex != "F"] <- "NA"

    # This includes all who are either not female or female and currently
    # pregnant
    NOT_CURRENTLY_PREGNANT <- dis_output$sex != "F" | dis_output$pregnant != "Y"

    dis_output$foetus_alive_at_admission[NOT_CURRENTLY_PREGNANT] <- NA
    dis_output$trimester[NOT_CURRENTLY_PREGNANT] <- NA
    # delivery event is a TRUE only category, meaning that it either is a 1 or
    # NA kind of thing.
    dis_output$delivery_event[NOT_CURRENTLY_PREGNANT] <- "NA"

    NO_DELIVERY <- dis_output$delivery_event != "1"

    dis_output$pregnancy_outcome_at_exit[NOT_CURRENTLY_PREGNANT] <- NA
    dis_output$pregnancy_outcome_at_exit[NO_DELIVERY] <- NA
  }


  if (dictionary == "Cholera") {
    dis_output$ors_consumed_litres <- sample(1:10, numcases, replace = TRUE)
    dis_output$iv_fluids_received_litres <- sample(1:10, numcases, replace = TRUE)
  }

  if (dictionary == "Measles") {
    dis_output$baby_born_with_complications[NO_DELIVERY] <- NA

    # fix vaccine stuff among non vaccinated
    NOTVACC <- which(!dis_output$previously_vaccinated %in% c("C", "V"))

    dis_output$previous_vaccine_doses_received[NOTVACC] <- NA
    dis_output$date_of_last_vaccination[NOTVACC] <- NA
  }

  if (dictionary == "Meningitis") {
    # T1 lab sample dates before admission
    # add 2 to admission....
    dis_output <- enforce_timing(dis_output,
      first  = "date_of_consultation_admission",
      second = "date_ti_sample_sent",
      2
    )

    # fix pregnancy delivery
    dis_output$delivery_event[dis_output$sex != "F"] <- "NA"

    # fix vaccine stuff among not vaccinated
    NOTVACC <- which(
      !dis_output$vaccinated_meningitis_routine %in% c("C", "V") &
        !dis_output$vaccinated_meningitis_mvc %in% c("C", "V")
    )

    dis_output$name_meningitis_vaccine[NOTVACC] <- NA
    dis_output$date_of_last_vaccination[NOTVACC] <- NA
  }

  if (dictionary == "Mortality") {

    # fix age in months variables
    dis_output$age_months <- dis_output$age_months_calc

    # calculated months based of year
    do_age_years <- dis_output$age_years
    under_six_years <- do_age_years < 6 & do_age_years > 0
    dis_output$age_months_calc[under_six_years] <- do_age_years[under_six_years] * 12

    # create household numbers within cluster numbers
    dis_output <- gen_hh_clusters(dis_output,
      n = numcases,
      cluster = "cluster_number",
      household = "household_number",
      eligible = "member_number"
    )

    # if consent is no then make everything else NA
    # NOTE: ZNK 2020-10-26: This is not very clear, but it seems like there is
    #  a column that _contains_ the value "no_consent_other", but may have extra
    #  decoration associated, which is why you are using grep, if this is not
    #  the case, you should just use which and equality:
    consent_columns <- which(names(dis_output) == "no_consent_other")
    consent_columns <- seq(consent_columns, ncol(dis_output))
    no_consent <- dis_output$consent == "no"
    dis_output[no_consent, consent_columns] <- NA

    # no_consent_reason shoud be NA if consent is yes
    dis_output$no_consent_reason[dis_output$consent == "yes"] <- NA

    # create index numbers and unique IDs
    # index is the unique household (the parent_index for kobo outputs)
    # index_y is the unique individual within households (index for kobo outputs)
    # uid combines these to produce a unique identifier for each individual
    dis_output <- gen_survey_uid(dis_output)


    # only read write if over fifteen years
    dis_under_15 <- dis_output$age_years < 15
    dis_output$read_write[dis_under_15] <- NA
    no_read_write <- dis_under_15 | dis_output$read_write != "yes"
    dis_output$education_level[no_read_write] <- NA

    # measles vaccination only for those between 5 and 60 months
    no_vaccine <- with(dis_output, age_months <= 5 | age_months_calc >= 61)
    dis_output$measles_vaccination[no_vaccine] <- NA

    # vaccination card only if answered yes to measles vaccination
    dis_output$vaccination_card[dis_output$measles_vaccination != "yes"] <- NA

    # fix pregnancy
    # define rows that cant be pregnant
    pregnancy_not_possible <- with(
      dis_output,
      sex == "male" | age_years >= 50 | age_years < 15
    )

    # set those who cant be pregnant to NA for pregnant variable
    dis_output[["pregnant"]][pregnancy_not_possible] <- NA

    # set pregnancy related cause of death for those who arent pregnant to be unknown
    no_pregnancy <- dis_output$cause %in% c("during_pregnancy",
                                            "during_after_delivery") &
      pregnancy_not_possible


    no_pregnancy[is.na(no_pregnancy)] <- FALSE # replace NAs

    # pregnancy related cause of death n.a. for too old/young and for males
    dis_output[["cause"]][no_pregnancy] <- "dont_know"

    # malaria treatment only among pregnant people
    dis_output$malaria_treatment[dis_output$pregnant != "yes"] <- NA

    # assume person is not born during study when age > 1
    OVER_ONE <- dis_output$age_years > 1
    dis_output$born[OVER_ONE] <- factor("No", levels(dis_output$born))
    dis_output$remember_dob[OVER_ONE] <- NA
    dis_output$birthday_date[OVER_ONE] <- NA



    # resample death yes/no to have lower death rates
    dis_output$died <- sample(c("yes", "no"),
      size = nrow(dis_output),
      prob = c(0.05, 0.95),
      replace = TRUE
    )

    # set columns that are relate to "death" as NA if "died" is "no"
    died <- dis_output$died == "no"
    dcols <- c(
      "remember_death",
      "death_date",
      "cause"
    )
    for (d in dcols) {
      dis_output[[d]][died] <- NA
    }

    # fix arrival/leave dates

    # cascaded of yeses dates and causes
    # and if did not arrive during study period or dont know date then NA

    not_arrived <- dis_output$arrived != "yes"
    not_left     <- dis_output$left != "yes"
    not_born     <- dis_output$born != "yes"
    not_died     <- dis_output$died != "yes"
    
    dis_output$remember_arrival[not_arrived] <- NA
    not_remember_arrival <- dis_output$remember_arrival != "yes"

    dis_output$arrived_date[not_arrived | not_remember_arrival] <- NA

    dis_output$remember_departure[not_left] <- NA
    not_remember_departure <- dis_output$remember_departure != "yes"

    dis_output$left_date[not_left | not_remember_departure] <- NA

    dis_output$remember_dob[not_born] <- NA
    not_remember_dob <- dis_output$remember_dob != "yes"

    dis_output$birthday_date[not_born | not_remember_dob] <- NA

    dis_output$remember_death[not_died] <- NA
    not_remember_death <- dis_output$remember_death != "yes"

    dis_output$death_date[not_died | not_remember_death] <- NA

    dis_output$cause[not_died] <- NA


    # set arrival date to the earliest date from those given
    dis_output$arrived_date <- with(
      dis_output,
      pmin(
        arrived_date,
        left_date,
        birthday_date,
        na.rm = TRUE
      )
    )

    # leave date
    dis_output <- enforce_timing(dis_output,
      first  = "arrived_date",
      second = "left_date",
      5:30
    )
    dis_output <- enforce_timing(dis_output,
      first  = "birthday_date",
      second = "left_date",
      5:30,
      inclusive = TRUE
    )

    # died date
    dis_output <- enforce_timing(dis_output,
      first  = "arrived_date",
      second = "death_date",
      5:30
    )
    dis_output <- enforce_timing(dis_output,
      first  = "birthday_date",
      second = "death_date",
      5:30,
      inclusive = TRUE
    )

    # fix cascade of violence
    vtype <- c(
      "violent_episodes_number",
      "violence_nature",
      "violence_nature/beaten",
      "violence_nature/sexual",
      "violence_nature/shot",
      "violence_nature/detained_kidnapped",
      "violence_nature/other",
      "violence_nature/no_response"
    )
    dis_output[which(dis_output$violent_episode != "yes"), vtype] <- NA

    dis_output[which(dis_output$violence_nature == ""),
               "violence_nature/no_response"] <- "1"
    dis_output$violence_nature[dis_output$violence_nature == ""] <- "no_response"

    # make sure ages are exclusive
    dis_output$age_years[dis_output$age_years == 0] <- NA_integer_
  }

  if (dictionary == "Nutrition") {
    dis_output <- gen_hh_clusters(dis_output,
      n = numcases,
      cluster = "cluster_number",
      household = "household_id"
    )

    # use household num as a standin for fact_0_id for now
    dis_output$fact_0_id <- dis_output$household_id


    # age in months (1 to 60 - i.e. under 5 years)
    dis_output$age_month <- sample(1:60L, numcases, replace = TRUE)

    # height in cm
    dis_output$height <- round(
      runif(numcases, 40, 120),
      digits = 1
    )

    # weight in kg
    dis_output$weight <- round(
      runif(numcases, 2, 30),
      digits = 1
    )

    # MUAC in mm
    dis_output$muac_mm_left_arm <- sample(80:190, numcases, replace = TRUE)
  }

  if (dictionary == "Vaccination") {

    # create household numbers within cluster numbers
    dis_output <- gen_hh_clusters(
      dis_output,
      n = numcases,
      cluster = "cluster_number",
      household = "household_number",
      eligible = "children_count"
    )


    # age in yr (0 to 15) - assuming doing vaccination coverage among those aged less than 15 yrs
    dis_output$age_years <- sample_age(15L, numcases)
    dis_output$age_months <- NA_integer_

    # age in mth (0 to 11)
    zero_yrs <- dis_output$age_years < 1
    dis_output$age_months[zero_yrs] <- sample_age(11L, sum(zero_yrs, na.rm = TRUE))
    dis_output$age_years[zero_yrs] <- NA_integer_

    # if consent is no then make everything else NA
    # dis_output[dis_output$consent == "no",
    #            c(grep("no_consent_other",
    #                   ntames(dis_output)):length(names(dis_output)))] <- NA
    # NOTE: ZNK 2020-10-26: This is not very clear, but it seems like there is
    #  a column that _contains_ the value "no_consent_other", but may have extra
    #  decoration associated, which is why you are using grep, if this is not
    #  the case, you should just use which and equality:
    consent_columns <- which(names(dis_output) == "no_consent_other")
    consent_columns <- seq(consent_columns, ncol(dis_output))
    no_consent <- dis_output$consent == "no"
    dis_output[no_consent, consent_columns] <- NA


    # no_consent_reason should be NA if consent is yes
    dis_output$no_consent_reason[dis_output$consent == "yes"] <- NA


    # create index numbers and unique IDs
    # index is the unique household (the parent_index for kobo outputs)
    # index_y is the unique individual within households (index for kobo outputs)
    # uid combines these to produce a unique identifier for each individual
    dis_output <- gen_survey_uid(dis_output)

    # NOTE: ZNK 2020-10-26
    # The vaccination routines here need to be turned into a function. There is
    # a lot of repetition here that needs to be contained and evaluated properly

    # add in age if routine vaccinated
    rout_vaccinated <- dis_output$routine_vacc %in% c("verbal", "card")
    non_empty_months <- has_value(dis_output$age_months)
    vaccinated_months <- rout_vaccinated & non_empty_months
    # sample months
    dis_output$age_routine_vacc[rout_vaccinated] <- sample_age(11L, sum(rout_vaccinated, na.rm = TRUE))
    # if age in months not empty just use that (otherwise will have some in future)
    vac_ages <- dis_output$age_months[vaccinated_months]
    dis_output$age_routine_vacc[vaccinated_months] <- vac_ages 
    # only fill in place of vaccination if vaccinated
    dis_output$place_routine_vacc[!rout_vaccinated] <- NA
    # only fill in reason no vaccination if not vaccinated
    dis_output$reason_route_vacc[rout_vaccinated] <- NA



    # add in age if msf vaccinated
    msf_vaccinated <- dis_output$msf_vacc %in% c("verbal", "card")
    vaccinated_months <- msf_vaccinated & non_empty_months
    # sample months
    dis_output$age_msf_vacc[msf_vaccinated] <- sample_age(11L, sum(msf_vaccinated, na.rm = TRUE))
    # if age in months not empty just use that (otherwise will have some in future)
    msf_ages <- dis_output$age_months[vaccinated_months]
    dis_output$age_msf_vacc[vaccinated_months] <- msf_ages
    # only fill in place of vaccination if vaccinated
    dis_output$place_msf_vacc[!msf_vaccinated] <- NA
    # only fill in reason no vaccination if not vaccinated
    dis_output$reason_msf_vacc[msf_vaccinated] <- NA


    # add in age if sia vaccinated
    sia_vaccinated <- dis_output$sia_vacc %in% c("verbal", "card")
    vaccinated_months <- sia_vaccinated & non_empty_months
    # sample months
    dis_output$age_sia_vacc[sia_vaccinated] <- sample_age(11L, sum(sia_vaccinated, na.rm = TRUE))
    # if age in months not empty just use that (otherwise will have some in future)
    sia_ages <- dis_output$age_months[vaccinated_months]
    dis_output$age_sia_vacc[vaccinated_months] <- sia_ages
    # only fill in place of vaccination if vaccinated
    dis_output$place_sia_vacc[!sia_vaccinated] <- NA
    # only fill in reason no vaccination if not vaccinated
    dis_output$reason_sia_vacc[sia_vaccinated] <- NA


    # add in age for children with measles
    meas_diag <- dis_output$diagnosis_disease == "yes"
    meas_diag[is.na(meas_diag)] <- FALSE
    vaccinated_months <- sia_vaccinated & non_empty_months

    # sample months
    dis_output$age_diagnosis[meas_diag] <- sample_age(11L, sum(meas_diag, na.rm = TRUE))
    # if age months not empty just use that (otherwise will have some in future)
    meas_ages <- dis_output$age_months[vaccinated_months]
    dis_output$age_diagnosis[vaccinated_months] <- meas_ages

  }


  # return dataset as a tibble
  dplyr::as_tibble(dis_output)
}
