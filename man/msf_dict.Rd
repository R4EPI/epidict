% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/msf_dict.R, R/msf_dict_survey.R
\name{msf_dict}
\alias{msf_dict}
\alias{msf_dict_survey}
\title{MSF data dictionaries and dummy datasets}
\usage{
msf_dict(
  disease,
  name = "MSF-outbreak-dict.xlsx",
  tibble = TRUE,
  compact = TRUE,
  long = TRUE
)

msf_dict_survey(
  disease,
  name = "MSF-survey-dict.xlsx",
  tibble = TRUE,
  compact = TRUE,
  long = TRUE,
  template = TRUE
)
}
\arguments{
\item{disease}{Specify which disease you would like to use.
\itemize{
\item \code{msf_dict()} supports "AJS", "Cholera", "Measles", "Meningitis"
\item \code{msf_dict_survey()} supports "Mortality", "Nutrition", and "Vaccination"
(only used in surveys if \code{template = TRUE})
}}

\item{name}{the name of the dictionary stored in the package.
\itemize{
\item \code{msf_dict_survey()} supports Kobo dictionaries not stored within this package,
to use these: specify \code{name}as path to .xlsx file and set the \code{template = False}
}}

\item{tibble}{Return data dictionary as a tidyverse tibble (default is TRUE)}

\item{compact}{if \code{TRUE} (default), then a nested data frame is returned
where each row represents a single variable and a nested data frame column
called "options", which can be expanded with \code{\link[tidyr:nest]{tidyr::unnest()}}. This only
works if \code{long = TRUE}.}

\item{long}{If \code{TRUE} (default), the returned data dictionary is in long
format with each option getting one row. If \code{FALSE}, then two data frames
are returned, one with variables and the other with content options.

@param template Only used for \code{msf_dict_survey()}.
If \code{TRUE} (default) the returned data dictionary is a generic
MSF OCA ERB pre-approved dictionary. If \code{FALSE} allows you to read in your
own Kobo dictionary.}

\item{template}{(for survey dictionaries): if \code{TRUE} read in a generic
dictionary based on the MSF OCA ERB pre-approved template. However you can
also specify your own dictionary if this differs substantially, by setting
\code{template = FALSE}.}
}
\description{
These function produces MSF OCA dictionaries based on DHIS2 (for outbreaks)
and Kobo (for surveys) data sets defining the data element name, code,
short names, types, and key/value pairs for translating the codes
into human-readable format.
}
\examples{

if (require("dplyr") & require("matchmaker")) {
  withAutoprint({
    # You will often want to use MSF dictionaries to translate codes to human-
    # readable variables. Here, we generate a data set of 20 cases:
    dat <- gen_data(
      dictionary = "Cholera",
      varnames = "data_element_shortname",
      numcases = 20,
      org = "MSF"
    )
    print(dat)

    # We want the expanded dictionary, so we will select `compact = FALSE`
    dict <- msf_dict(disease = "Cholera", long = TRUE, compact = FALSE, tibble = TRUE)
    print(dict)

    # Now we can use matchmaker to filter the data:
    dat_clean <- matchmaker::match_df(dat, dict,
      from = "option_code",
      to = "option_name",
      by = "data_element_shortname",
      order = "option_order_in_set"
    )
    print(dat_clean)
  })
}
}
\seealso{
\code{\link[matchmaker:match_df]{matchmaker::match_df()}} \code{\link[=gen_data]{gen_data()}} \code{\link[=msf_dict_survey]{msf_dict_survey()}}
}
